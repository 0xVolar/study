这是solidity的笔记 2022.10.12
# 声明 #
    // SPDX-License-Identifier: MIT
1. 在每一个合约的开头都需要进行一个版权声明
# 版本号的声明 #
    pragma solidity ^0.8.17;
1. 对于版本号的声明参照以上的代码，在**0.8.17**之前使用了一个**^**表示该编译可以在8.0版本以内8.17版本之上进行编译（9.0不一定可以编译）
2. 同时**^**也可以替换为**>**、**=**、**>=**，也都可以。
3. 也可以不选择使用符号，如`pragma solidity 0.8.17;`，这就表示为只是用**0.8.17**这个版本进行编译。

# 数据的存储位置 #
- `memory`
    - 该存储类型为新建立的一片存储空间，该空间的**有效时间为方法结束之后**，并且对于其的操作（值修改，赋值等），均不会产生根本的改变，在方法结束之后就失效。总结即为：该类型的为**值传递**，不会对真正的值产生效果

- `storage`
    - 该存储类类型，即存储的是状态变量，声明之后会将其存储在链上，对其的操作会对其进行根本的改变，即：该类型为**指针传递**

- `calldata`
    - 该类型与memory类似，但是只能用于**输入参数**中，并且函数之间的调用使用的是**caldata**的话，相较于memory新建空间，calldata不用新建空间，可以大大**节约gas**。

# 类型和值 #
## solidity有以下常用的类型 ##
1. **bool**
    1. `bool public b = true;`
    2. bool类型的值有两种，true或false
    3. **在声明时的public表明该类型为可见的，而且public还提供了一个get()方法，获取值，使得该值为可读的**
    4. **默认值为false**

1. **uint**
    1. `uint public u = 123;`
    1. uint为无符号正数
    2. uint默认为uint256，范围为0~2**256 - 1，如果需要其他的数的话，须指明,例如：`uint8`,`unit16`...`uint256`。不同的的声明所能表示的值的范围不同，在使用时需要考虑是否有值溢出的现象。
    3. **默认值为0**

1. **int**
    1. `int public i = -123;`
    2. 声明了int类型就可以声明负数，int默认为int256，和uint一样类推
    3. 与uint不同的是，int的范围，int256，范围为0~2**255 - 1。这是因为需要用一位(bit)来表示正负
    4. **默认值为0**

1. **address**
    1. `address public addr = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;`
    2. 这是solidity语言特有的变量类型，以16进制的方式来进行表示
    3. **默认值为0地址**

1. **byte32**
    1. `bytes32 public b32 = ;`
    2. bytes类型的最大值为32，即只能声明`bytes32`。不同的声明范围所表示的范围也不同，bytes32即表示一个256位(bit)的数。
    3. **默认值为32字节的0**

## 定义不可变量 ##
- ` address public immutable owner = msg.sender; `
  - 在声明变量时使用**immtable**进行修饰，将改变量定义为不可变量，也即为常量；这样的操作可以节约gas费用。并且也可以**通过函数构造器为常量赋值**，但是在常量声明之后在**后续操作中不可以更改其值**。

# 函数 #
## 只读函数的变量修饰符 view和pure ##
- `view`：使用**view**是需要返回区块链中的信息，通过view可以获取区块链上的信息，然后进行返回，即除局部变量外的其他变量
    - eg：`function viewFunc() external view returns (uint){}`

- `pure`：使用**pure**只能返回局部变量，无法获取区块链上的数据，即为只能调用传参
    - eg：`function pureFunc() external pure returns (uint) {}`

## external、public、private修饰符 ##
- **external**
    - `function loops() external {}`
    - **external**修饰符说明该函数只能在合约外进行调用，在同一个合约中的其他函数无法调用该函数

- **public**
    - `function loops() public {}`
    - **public**修饰符表明该函数可在合约外进行调用，同时，在同一个合约中的其他函数也可以调用该函数

- **private**
    - `function loops() private {}`
    - **private**修饰符表明该函数只能被同处一个合约中的其他函数进行调用，在合约外不会进行显示，即不可调用

## 函数修改器 ##
- 定义
    - `modifier 修饰名() { code }`
    - 带参数：`modifier 修饰名(参数名) { code }`
    - 在写内部方法中需要加上`_;`，这是用来表明调用该修饰器的函数执行，对其进行一个触发
    - eg：
    - `require(!paused, "paused");`
       ` _;`

- 使用
    - `function inc() external whenNotPaused {}`
    - 有传入参数：`function 函数名(uint _x) external cap(_x) {}`
    - 再调用函数前想要进行某些认证的话，需要进行使用，函数修饰符来进行想要的判断，这样最大大的节省了代码，并且利于维护

## 构造函数 ##
- `constructor(参数名) { code }`
    - 构造函数，只能在合约被部署的时候调用一次，可用来完成函数变量初始化的操作

## 回退函数 ##
- 回退函数有两种用法
  - 当调用该合约中不存在的方法时，会调用**回退函数**，执行里面的逻辑
  - 当该合约要进行以太坊主币的接收时，会调用**回退函数**

- **具有回退函数并且有payable关键词的合约**才能够进行以太坊主币的接收。

- ` callback() external payable { code }`
  - 该方法为默认方法，当调用时传入数据时，会调用**callback函数**，同时调用不存在合约时也会调用该函数。
- ` receive() external payable { code } `
  - 该方法用于当调用时没有传输数据时，调用**receive函数**。当调用时不存在传入数据时，先查看是否定义了**receive方法**，如果有的话就执行，没有的话就执行**callback方法**

# 变量 #
## 状态变量 ##
- 状态变量相当于是把变量写到链上，如果不使用修改方法对变量进行修改的话，该变量将一直持续存在于链上
## 局部变量 ##
- 声明在函数中的变量，只有在调用函数的时候，该变量才会生效，当函数停止调用时，局部变量也会被删除，不会被写到链上 
## 全局变量 ##
- 全局变量位不用定义即可显示其内容的变量，这些变量记录了链上的信息和账户信息，例如：
    - `msg.sender`：通常是写在函数中，会表示调用该函数的地址（地址或合约地址）
    - `block.timestamp`：表示时间戳，如果是只是读取操作的话，会读取当前的时间戳；如果采用的写入的操作的话，返回的时间为出块的时间戳
    - `bliok.number`：表示当前的区块号

# 常量 #
- `address public constant MY_ADDRESS = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;`
    - 常量的声明，即在变量中加入**constant**，并且常量的名称默认为大写，中间用下划线**_**进行连接。使用常量可以减少gas费的消耗

# Error控制 #
## 智能合约中的三种报错控制方法 ##
1. `require`
    - `require(判断条件, 输出语句);`
    - **require**前半部分为判断条件，根据需要进行设置，后半部分为不满足要求后的输出语句，后半部分在实际编写中可以进行一个省略
2. `revert`
    - `revert("输出语句");`
    - **revert**不同于require，他只有一个错误时的输出语句，如果要使用的话需要先进行一个判断
3. `assert`
    - `assert(判断条件);`
    - **assert**是一个断言的手段，可以根据需要进行使用，并且assert会将本次交易所剩的燃料全部消耗
    - 该错误返回的是

1. 自定义错误
    - `error 函数名();`
    - 通过自定义一个**error**类型的函数，在进行错误控制时，使用`revert 函数名()`，进行错误的抛出。这样可以节省gas，并且可以自定义想要返回的错误种类。

# 数组 #
## 数组的类型 ##
- 动态数组
    - `uint[] public nums = [1, 2, 3];`
    - 在声明时，在方括号中不需要填入数字，这时即为动态数组，动态数组可以不用考虑越界的问题


- 定长数组
    - `uint[3] public numsFixed = [4, 5, 6];`
    - 在声明时，在方括号中需要填入数字，表明该数组的长度，再往该数组添加数据的时候，不可超过数组的长度

## 数组的操作方法 ##
- `push();`
    - 该方法是将数据加入数组的末尾，**只在动态数组中使用**

- `pop()`
    - 该方法是将数组中队尾的数据进行弹出，弹出后，处在队尾的数据就消失了，数组长度减一，**只在动态数组中使用**


- `delete`
    - 该方法是将数组中的某一项进行删除，但是删除只是将该数据还原成默认值，并不会对数组的长度进行一个改变，如果想要改变数组长度的话，可以使用**pop**方法

- `length`
    - 该方法可以获取数组长度

## 在内存中创建数组 ##
- `uint[] memory a = new uint[](5);`
- 在内存中创建数组，此时该数组为**局部变量**；并且在内存中只可创建定长数组，不可创建动态数组。并且不可使用**push()**、**pop()**方法，因为这两种方法会造成数组长度的变化。

## 方法返回数组 ##
- `function returnArray() external view returns (uint[] memory) { code }`
- 需要特别注意的是，**通过函数返回的数组必须要有存储类型**。

# 映射 #
## 映射的声明 ##
- `mapping(address => uint) public blances;`
- 映射就是类似于图的结构，却比图更加的方便。在某些情况使用时相较于数组可以更好地去节省gas。

## 映射的方法 ##
- 设置数据
    - `balances[msg.sender] = 123;`
    - 设置数据通过方括号的方式来进行设置，**设置的数据必须符合之前定义的数据**
    - `isFirend[msg.sender][address(this)] = true;`
    - 对于嵌套映射的数据设置，**主意好嵌套的顺序即可**

- 获取数据
    - `uint bal = balances[msg.sender];`
    - 获取数据的话也是通过方括号的方式来获取，如果映射中有相应的值就会返回对应的值，如果

- 删除数据
    - `delete balances[msg.sender];`
    - 同删除数组方法一样，**delete方法对映射的删除只是把值变为默认值**

# 结构体 #
## 结构体的定义与声明 ##
- `struct{类型1 名称1; 类型2 名称2; 类型3 名称3;}`
    - 结构体是一种包含了各种各样的的数据类型的一种数据结构，在结构体中可以定义自己所需要的类型。

- 结构体的声明
    - `结构体名 memory 变量名 = 结构体名(数据, 数据2, 数据3);`
        - 使用结构体时采用**小括号**，按照先前定义好的数据类型的**顺序填入**

    - `结构体名 memory 变量名 = 结构体名({类型1: 名称1, 类型2: 名称2, 类型3: 名称3});`
        - 第二种方法是采用**花括号**的形式，并且按照**key-value**的形式填入先前在结构体中定义好的数据，此时可以**不用按照顺序填入**

    - `结构体名 memory 变量名`
    - `变量名.类型名 = 数据`
        - 第三种方式就是先声明结构体，此时里面的类型会变成**默认值**，然后通过**变量名.类型名 = 数据**的方式可以对其进行赋值.

- 结构体的存储类型
    - `memory`
        - 该存储类型为新建立的一片存储空间，该空间的**有效时间为方法结束之后**，并且对于该空间的操作（值修改，赋值等），均不会产生根本的改变。总结即为：该类型的为**值传递**，不会对真正的值产生效果

    - `storage`
        - 该存储类类型，即存储的是状态变量，对其的操作会对其进行根本的改变，即：该类型为**指针传递**

## 结构体的操作 ##
- 结构体中的数值获取
    - `类型 变量名 = 结构体的变量名.类型名称`
    - 通过**结构体的变量名.类型名称**的方式可以获取结构体内部的数值，但是必须**确保类型的一致性**

- 结构体中的删除
    - `delete 结构体的变量名.类型名称`
    - 该方法仅仅只是将**值变为初始值**而已

# 枚举 #
## 什么是枚举 ##
- 当想表达多种状态时，可以使用枚举类型，枚举可以使一个**变量拥有多种状态**，枚举与结构体一样，都是一种数据结构，一种类型。
- 枚举值的大小为**uint8**，并且枚举值的范围为**0x00~0xff**。在方法调用返回结果时，也为**uint8**

## 枚举类型的声明 ##
- `enum Status {status1, status2, status3...}`
    - 当你使用枚举类型时，返回的不是定义的状态的名称，而是该状态在枚举中的值的**下标**(从0开始)
    - 枚举类型的**默认值为第一个状态**

# 事件 #
## 事件的声明 ##
- `event Log(事件的类型1 变量1, 事件的类型2 变量2);`
- `event IndexedLog(事件的类型1 indexed 变量1, uint val);`
    - 事件是记录当前智能合约运行状态的方法，但是却**不会记录到状态变量**中。而是会体现到**区块链浏览器**中，和输出中的**Log记录**中。
    - 事件的激发，使用`emit(变量1， 变量2)`;**事件的变量开头字母大写**
    - 在一个事件中，带有**索引标志的变量最多只有3个**。
    - 带有索引的变量可以在链外进行搜索查询。

# 继承 #
## 继承的定义 ##
- 当一个**合约B**想要使用另一个**合约A**的某些方法时，可以将合约A定义为**父合约**，在合约A中将可以重写的方法进行声明，使用`virtual`函数修饰符说明
    - `function foo() public pure virtual returns (string memory) {}`
- 在solidity语言中，不存在**方法的重载**，有**方法的重写**，在继承类中，对于需要使用的A中的方法，但是**对返回值进行修改**时，需要加入`override`的修饰符，来说明这是重写的方法。否则返回值会是在合约A中定义的一样
    - `function foo() public pure override returns (string memory) {}`

- 合约B对合约A的继承，需要在合约中说明
    - `contract B is A {}`

## 多线继承 ##
- 多线继承的规则：**从基类到派生**的顺序关系
- 如果合约C中的方法在多个合约都有的话，在方法重写声明的时候在override后面要用括号将继承的合约加入
    - `function foo() public pure override(X, Y) returns (string memory) {}`
    - 在override中的合约顺序，**不用遵守多线继承的规则**

## 父级合约拥有构造参数的情况 ##
- 在父级合约存在构造参数的情况下，子级合约如何输入参数
    - `contract U is S("s"), T("t") {}`
        - 在**继承时就在父级合约中输入参数**，这个方法最主要的点为要提前知道**父级合约中的构造函数的输入情况**

    - `constructor(string memory _name, string memory _text) S(_name) T(_text) {}`  
        - 第二种方法是在，**子合约中重新设置一个构造函数，并将构造函数的参数传到父级合约中**，

    - 上述两种方法可以混合使用

- 父级合约**构造参数的执行顺序按照继承的先后顺序进行执行**，在合约中的构造函数后的父级合约的顺序无关
    - `contract U is S("s"), T("t") {}`
        - **此时就先执行S，在执行T**

## 调用父级合约函数 ##
- 直接调用
    - `父级函数的名称.函数名`

- 使用super关键词
    - `super.函数名`
    - 该方法会自动寻找**所有父级函数**中**相对应的函数名**进行使用，但是**同一合约中的函数不会被调用多次，只会被调用一次**

# 可视范围 #  
## 修饰符 ##  
- `public`
  - 用来修饰**函数**与**变量**，声明的函数和变量在合约外部与合约内部都能够进行调用，并且继承的子类合约也能够进行调用。
- `private`
  - 用来修饰**函数**与**变量**，但是声明的合约与变量均只能在本身的合约中进行调用。继承的子合约也无法进行调用。
- `internal`
  - 用来修饰**函数**与**变量**，但是声明的合约与变量均只能在本身的合约中进行调用。但是继承的子合约也可以进行调用。
- `external`
  - 只能用来修饰**函数**，声明的函数**不可以在合约内部进行调用**，只能由合约的调用者或者调用该合约的合约进行调用，并且继承的子类中也不可以调用该函数。
  - 如果非要在合约中调用该函数，使用` this.函数名 `，其作用为先到外部，在从外部进行函数的调用。这样会**浪费gas**。

# Payable的关键词 #
## 声明 ##
- **payable 意味着在调用这个函数的消息中可以附带 Eth**、**使用 payable 标记的 Solidity 地址变量，允许发送和接收 Eth**
- ` function deposit() external payable {code} `
  - 在声明函数时，加入**payable**关键词，表示该函数可以用来接收以太坊主币的传入
- ` address payable public owner; `
  - 在声明变量是加入**payable**函数，表示该变量可以发送以太坊主币。

# 合约发送主币 #
## 合约发送主币的三种方法 ##
- ` transfer `
  - transfer的发送方法消耗的燃料上限为**2300gas**，一旦耗尽就执行**reverts**方法
- ` send `
  - send的发送方法消耗的燃料上限为**2300gas**，但是send方法最后会**返回一个bool值表示发送成功还是失败**，
- ` call `
  - call方法会**发送剩余的gas**让接收的合约执行完逻辑，并且会**返回一个bool值和一个data**

# 合约调用其他合约 #
## 两种方法 ##
- 在当前合约中想要调用其他合约，可以在**方法里面将调用的合约作为类声明，往里面传入地址**即可。然后也可以调用调用合约里面定义的方法
  - `TestContract(_test).setX(_x);`

- 在方法声明的时候，**传参里面加入要调用的合约作为类**来使用
  - ` function setX(TestContract _test, uint _x) external {} `

## 接口合约 ##
- 当想要使用某个合约中的某些方法时，由于合约过于复杂，内容较多等原因，所以可以使用**接口合约**。与go语言中类似，在接口合约中，只进行对方法的声明，并不进行具体的实现，通常**接口名的定义首个字母必须为I**。
  - ` interface I接口名 { 方法1， 方法2 } `
- 在使用时，需要将**引用的合约的地址作为参数传入**，才能够进行方法的调用。

## 合约调用 ##
- ` call `
  - ` (bool success, bytes memory data) = _test.call(abi.encodeWithSignature("setVars(uint256)", _num)); `
  - 在调用时可以使用签名的方法进行合约的方法的调用
- ` delegatecall `
  - **委托调用**的合约必须和调用合约拥有相同的布局，**同样的变量**，**同样的变量名**，**同样的顺序**
  - **不会对调用的合约的值进行更改**，只会对当前合约的值进行更改，**前提是当前合约和调用合约具有一样的配置**（相同类型的变量和变量名）
  - ` (bool success, bytes memory data) = _test.delegatecall(abi.encodeWithSelector(TestDelegateCall.setVars.selector, _num)); `

# 库合约 #
- 库合约相当于一个**方法类的封装库**，在里面有定义好的方法，在合约中使用时，可以**先声明一个库的类**，然后进行方法调用**库合约名.方法名**。库合约的名字大写开头。
- `using`
  - ` using 库合约 for 一种类型 `
  - 使用这种方法，可以将**库运行用在某种类型上**，之后当使用这种类型时可以快速使用方法，**类型.方法**即可快速使用。

# 哈希运算 #
- `keccak256(abi.encodePacked(text, num, add));`
  - 在solidity中可以使用**keccak256**方法进行哈希运算，使用**abi.encodePacked**或**abi.enode**进行打包输入，输出的会得到一个**bytes32**类型的变量。
  - **abi.enode**，返回的是**不定长的bytes类型**，会自动进行补零操作
  - **abi.encodePacked**，返回的是一串**16进制的数字**，并不会自动补零