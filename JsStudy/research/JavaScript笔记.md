# 这是学习JS的文档 #
# JS的基本介绍 #
- Js是一门**动态语言**，即为变量的类型不确定，可能会发生变化
- Js是一门**解释性语言**，Js的执行**不需要经过编译**就可执行
- Js是一门**面向对象**的语言
- Js严格**区分大小写**

js是一门**嵌入式的语言**，本身的核心算法并不多，只能做一些简单的数学逻辑运算，常用来实现对宿主环境底层提供的API进行调用。用来控制宿主环境的接口。

# 基本语法
## 变量
### 变量的声明
- ` var 变量名 = 变量的值; `
  - 使用` ; `结尾的为**语句**，不使用` ; `结尾的为**表达式**。语句一般为要执行某个操作，而表达式表示想要获取某个值。.
  - 变量名不能以数字开头，不能有+号，不能是保留字符，不能有*号，**可以使用中文字符作为变量名**
- **JS严格区分大小写**，对于变量名的选择，大小写不同即为两个变量名。
- **第一次使用变量在使用时必须要声明**
- 在js中变量的类型没有限制,**如果要对已经声明并赋值的变量要改变其值的话直接使用变量名进行赋值即可**，也可以使用var进行声明
  - ` var a = 12321; `
  - ` var a = "sdsds" `  

## 循环控制
- **if语句**
  - ```
    if(判断条件) {
        code;
    } else if(判断条件) {
        code；
    } else{
        code
    }
    ```
  - 也可以不使用`{}` 对代码进行限制，可以使用表达式**将语句直接接在if(判断条件)后面**。如果要**在下一行则需要进行缩进控制**。
- **switch**
  - ```
    switch(条件) {
        case 条件1:
            code;
            break;
        case 条件2:
            code;
            break;
        default:
            code
    }
    ```
  - 如果不使用`break`的话，即使有对应的条件，也不会终止，会一直进行找下去，最终执行default语句。
  - 如果不使用`{}`的话,可以使用表达式

- **for循环**
  - ```
    for(初始化表达式; 限制条件; 递增条件) {
        code;
    }
    ```
  - 如果不使用`{}`的话,可以使用表达式;同时要使用for进行无限循环表示的话，需要有终止条件
- **while循环**
  - ```
    while(条件) {
        code;
    }
    ```
  - 如果不使用`{}`的话,可以使用表达式，**在使用while时，必须使得其可终止**

- **do...while循环**
  - ```
    do {
      code
    }
    while(判断条件)
    ```
  - 与**while循环**不同，**do  while**是先执行方法，在进行条件判断。

在使用循环时可以使用` break `和` continue `进行停止或者跳过。但是**break在停止循环时，只能够停止一层循环**。如果想要**停止多重循环**，可以使用**多个break**，或者**使用label**来停止。同时配合**continue**语句进行使用。
  - **label**
    - ```
      label:
        code
      ```

## 数据类型
Js的数据类型分为**原始类型（数值，字符串，布尔值）**和**合成类型（对象）**，合成类型其实是由多个原始类型合成而来。对于**空值使用null**表示，**未定义的值使用undefined**进行表示。
### 判断数据类型
- **typeof**运算符
  - `typeof 123`
  - `typeof "ssssss"`
- **instanceof**运算符
- **Object.prototype.toString**方法

### null and undifined
在语法上**null**与**undifined**都表达着没有的意思。当null和undifined**用于判断语句时，会默认将其转化为false**。
- 区别
  - **null**，表示空值，其实如同java语法一样，在表达中，**null被当作数字0**看待
  - **undifined**，表示未被定义，在对其数值进行判断时，表达的是**Nan**

- 使用
  - ` var i = undifined;`
  - ` var i = null; `

### bool布尔值
bool值用来表达对判断的结果的表示，布尔值常用来对逻辑进行判断。
- 使用
  - ` var a = true; `

- **表达false的值,其余的值都表达为true**
  - `undefined`
  - `null`
  - `false`
  - `0`
  - `Nan`
  - `""` || `''`

- 在对**空数组**和**空对象**进行判断时，**也是true**

### 数值(number)
number，包括整数和小数（浮点数），**在Js内部，所有的数字都是以64位浮点数的形式进行存储**，不管是整数还是小数。**数值的精度最多只有53个二进制位**，即-2^53 到2^53，超过之后就会发生精度缺失。
- **数值范围**
  - Js中当大于2^53时，会发生精度错误，但是当 **大于2^1024（正数）时，就会发生正向溢出**， 会进行Infinity溢出报错。当**小于-2^1075时，会发生负向溢出**。

- 数值的表示方法
  - 在js中对数值的表示可以采用**进制**进行表示和采用**科学计数法**进行表示
    - 科学计数法
    - ```
      123e3 // 123000
      123e-3 // 0.123
      ```
    - e或E后面会跟一个整数，表示指数部分，**复数代表往前**，**正数代表往后**。当**小数点前的数字多于21位**，**小数点后的零多于5个**，都会自动使用科学计数法。

- 数值的进制
  - 10进制：前缀什么都没有
  - 16进制：前缀为0x或0X
  - 8进制：前缀为0o或0O
  - 2进制：前缀为0b或0B

- NaN：表示为**非数字**，在字符解析为数字出错时会进行抛出，NaN只能算作一个特殊的值，在类型方面来说还是属于number。
- Infinity：表示无穷，当一个数的数值过大时会进行抛出，**Infinity有正负之分**。
- **与数值相关的全局方法**
  - `parseInt(数值，进制（可省略默认为10）)`：用于将**字符串转化为数值**，在**进行转换的时候是一个一个字符进行转换的**，当遇到无法识别的字符时会停止并返回已经转换好的字符。如果传入的参数为数值的话，会先转换为字符再进行转换。如果第一个字符无法转换会返回NaN。
  - `parseFloat()`：将**字符串转换为浮点数**，如果**字符串符合科学计数法的表达式的话**，会进行表达。当遇到无法识别的字符时会停止并返回已经转换好的字符，会将空字符串转换为NaN，
  - `isNaN()`：可以判定一个字符是否为NaN，只对数值有效，如果传入其他类型会先转换为数值
  - `isFinite()`：判断一个数值是否为正常的值

### 字符串
**字符串就是零个或多个排在一起的字符，放在单引号或双引号之中**。字符串默认只能写一行，**如果想要进行多行表示的话可以使用转义字符或者+号进行拼接**。
- 字符串与数组
  - **字符串可以视为字符数组**，可以通过`str[index]`的方式来**返回在字符串中具体的位置的字符**。与数组的方式不同，**这样的方法只可以获取具体的字符，但要对具体位置的字符进行修改的话是不可以的**。
  - `length`：**length方法可以对字符串的长度进行返回**，与数组的length用法一样。但是**只能查询不能修改**。
- 字符串的字符集
  - **JS使用的是Unicode字符集**，还允许直接在程序中使用 Unicode 码点表示字符，即将字符写成\uxxxx的形式，其中xxxx代表该字符的 Unicode 码点。
  - **JS中每个字符的存储大小为16bit（2bytes）**。对于码点在U+0000到U+FFFF之间的字符，长度为16位（即2个字节）；对于码点在U+10000到U+10FFFF之间的字符，长度为32位（即4个字节）。但实际上**JS内部编译器已经定型，只能够识别2个字节的字符，对于4字节的字符会分成两个2字节进行识别**。

- base64转码
  - 在js中提供了base34转码的功能，可以**将文本中不可打印的字符进行转换**，并且如果想**以文本格式传递二进制码的话也可以使用**
    - `btoa()`：任意值转换为Base64编码
    - `atob()`：将Base64编码转换为原来的值
    - 上述两个方法只适用于ASCII码的字符，如果想转化非ASCII码的字符，必须在中间加入一个转码环节

### 对象（Object）
对象在JS中属于一种数据类型，是“**键值对(key-value)”的集合**，是一种无序的符合数据集合。对象的属性可以动态创建，
```
  var obj = {
    foo: "hello",
    bar: "world"
  };

  //动态创建属性
  var obj = {}；
  obj.foo = 123；
```
- **键名的类型都为字符串**，键名的命名必须符合标识名的条件，如果不符合的话必须加上引号，否则会进行报错。
- **值的类型可以是任意类型**，即为任何数据类型都可以。
- 对象的引用，**在JS中的值的应用属于地址传递，指向的是内存地址**，如果多个变量指向同一个对象，一个变量对对象进行更改的话，其他变量也会受到影响。而**对于其他变数据类型来说是值传递**，更改不会影响其他的变量（指向同一个数据类型的）。
- `with(对象名)`：使用with语句可以对对象的多个变量进行操作。
  - ```
      var obj = {
        p1: 1,
        p2: 2,
      };
      with (obj) {
        p1 = 4;
        p2 = 5;
      }
      // 等同于
      obj.p1 = 4;
      obj.p2 = 5;
    ```
  - with语句只能操作已经存在的属性，对于不存在的会创造一个相同的全局变量。


#### **值的读取**
  - 运用.运算符`对象名.属性`，数值键名不能使用点运算符
  - 运用方括号运算符`对象名['属性名']`，如果输入数值的话会转换为字符串


#### 获取对象
- `Object.keys()`:会将对象的所有属性名进行返回。
- `valueOf()`方法总是返回对象的所有内容。


#### **值的删除**
- **使用`delete`命令可以删除对象的属性**，如果删除的是不存在的值时，不会发生报错，会返回true。当使用`Object.defineProperty()`方法进行定义的对象时，使用delete方法进行删除是不可以的。
- 同时**delete是无法删除对象继承的属性**。

#### 查看属性是否存在
**使用`in`运算符可以查看对象是否包含某个属性，返回的值为true或false**，但是在使用时in无法识别那些属性是对象自身的，那些时继承而来的。如果**要进行是否属于自身的话可以使用`hasOwnProperty()`进行判断**。

#### 属性的遍历
- 在进行属性遍历的时候可以使用`for(属性名 in 对象)`来进行属性的遍历。
  - **`for in`遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性**。
  - **`for in`不仅遍历对象自身的属性，还遍历继承的属性**。

### 函数（function）
#### 函数的三种声明方式
- **直接命名**：`function 方法名(参数...){code} `
- **函数表达式**： `var 变量名 = function(参数...){code};`，通过将匿名函数赋值给变量。如果**在写方法时加入了方法名，该方法名只会在方法内部有效**。匿名函数可以通过`变量名()`进行调用。
- **Function构造函数**：
  - ```
    var add = new Function(
      'x',
      'y',
      'return x + y'
    );
    ```
  - 可以通过构造函数的方法进行函数的声明，**可以向构造函数中传入参数，但是最后一个传入的参数会被默认为函数体**，并且Function命令可以不使用new。

- 函数如果被多次声明的话，后面声明的函数会将前面的函数覆盖。

#### 函数的方法
- `name`：通过name可以获取函数的名称
- `length`：通过length可以获取函数的传参个数，在**JS中方法的参数是可以进行省略**的，而**length返回的是预期的参数个数**
- `toString()`：该方法会返回一个字符串，内容为该函数的源码，而且在函数内部使用注释也会被返回

#### 函数的传递方式
在函数传参，传入不同类型的参数会有，不同的效果。
- 传入类型为**原始类型（数值、字符串、布尔值）**，对于这些参数是进行的**值传递**，对参数进行修改不会影响原本的值
- 传入类型为**复杂类型（数组、对象、其他函数）**，对于这些参数是进行的**址传递**，对参数进行修改的话会影响原本的值。但是如果在函数内部不是修改对象的某个属性而是替换掉整个参数的话，这样是不会生效的。

#### 函数的参数
- **函数中允许存在同名参数**，但是在**使用同名参数时会使用最后声明的参数**。如果要使用其他的同名参数的话可以使用**arguments对象**。
- **arguments对象**：**arguments对象是一个传入参数的数组**，并且在**正常模式下arguments对象可以在运行时进行修改**。在**严格模式下arguments对象与函数参数不具有联动关系**。也就是说，修改arguments对象不会影响到实际的函数参数。
  - arguments严格意义上来说不是数组而是一个对象，如果要转为数组的话有两种方法**slice方法和逐一填入新数组**
  - callee属性，该属性会返回对应的原函数，在正常模式下使用该属性可以达到一个调用自身函数的目的。

- eval命令
  - **eval命令接受一个字符串作为参数，并将这个字符串当作语句执行**
  - JavaScript 的标准规定，凡是使用别名执行eval，eval内部一律是全局作用域。即为不管是否在函数内部执行，作用域都为全局作用域。

### 数组
数组（array）是按次序排列的一组值。每个值的位置都有编号（从0开始），整个数组用方括号表示。**任何类型的数据都可以放入数组当中**。本质上**数组属于一种特殊对象，数字的键值总是默认为0、1、2、3**......。**如果数组的键名是添加超出范围的数值，该键名会自动转为字符串**
- length，**数组的length属性是一个动态的值，该值等于键名中最大的整数加1**。所以说如果想要用length来表达数组中的元素个数的话，需要按顺序进行填入。
- **length属性是可写的**。如果人为设置一个小于当前成员个数的值，该数组的成员数量会自动减少到length设置的值。
- 使用delete命令删除一个数组成员，会形成空位，并且不会影响length属性。
- 数组的某个位置是空位，与某个位置是undefined，是不一样的。如果是空位，使用数组的`forEach`方法、`for...in`结构、以及`Object.keys`方法进行遍历，**空位都会被跳过**。undefined不会被跳过，会认为该键值有值为undefined。

## 错误控制
### Error
JS原生提供一个**Error构造函数**，调用构造函数可以生成一个实例对象err。**Error()构造函数接受一个参数，表示错误提示**，可以**从实例的message属性读到这个参数**。抛出Error实例对象以后，整个程序就中断在发生错误的地方，不再往下执行。
```
var err = new Error('出错了');
err.message // "出错了"
```
同时**Error实例**还提供了**name**和**stack**属性，通过简单的name和message属性可以大致的了解错误。

### 原生错误类型
- **SyntaxError**
  - 表示解析代码时发生的语法错误

- **ReferenceError**
  - 引用一个不存在的变量发生错误，或者将值分配给无法分配的对象

- **RangeError**
  - 值超出有效范围时发生的错误。情况为数组长度为负数，或者参数超出范围

- **TypeError**
  - 对象是变量或者参数不是预期类型时发生错误

- **URLError**
  - URIError对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及**encodeURI()**、**decodeURI()**、**encodeURIComponent()**、**decodeURIComponent()**、**escape()**和**unescape()**这几个函数。

### 自定义错误
在JS中用户可以自定义错误类型，通过继承Error对象，进行自定义的错误类型
```
  function UserError(message) {
    this.message = message || '默认信息';
    this.name = 'UserError';
  }

  UserError.prototype = new Error();
  UserError.prototype.constructor = UserError;
  new UserError('这是自定义的错误！');
```

###


# 标准库
## Object对象
Js中提供了原生的Object的对象，所有在Js中的对象都是继承Object对象，这些对象都是Object对象的实例
- `Object()`
  - Object本身也是一个函数，用来将一个值装换成一个对象，如果值为对象的话就不用进行转换。
- Object也可以作为一个**构造函数**进行使用，与`Object()`语义不同，构造函数表示的是新建一个对象。

### Object的实例方法
每一个对象都继承了**Object.prototype**，都是一个实例，可以通过`.方法名`使用实例方法。
- `Object.prototype.value()`：获取对象的值，默认情况下返回本身+
- `Object.prototype.value()`：返回对象的字符串形式，默认情况下返回类型的字符串，字符串会说明对象的类型，通常情况下可以使用`Object.prototype.toString.call(value)`方法对值类型进行一个判断。
- `Object.prototype.toLocaleString()`：与toString的作用一样。
- `Object.prototype.hasOwnProperty(string)`：该方法接受一个字符串作为参数并返回一个布尔值，用于验证对象中是否有该属性。