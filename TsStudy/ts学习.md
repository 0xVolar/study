# TS的值和类型

## 三种基本类型

- **any类型**：any类型代表了所有类型，any类型可以兼容所有类型，同时也可以赋值给所有类型，这就导致可能会产生**污染问题**。建议很少使用此类型
  - 使用编译命令时可以使用`tsc --noImplicitAny xx.ts`避免any的使用。
- **unkonwn类型**：是一个较为严格一点的any类型，unknown类型的值只能够赋给any型和unknown型。**不能直接调用unknown型的方法和属性**。unknown类型只能够进行**比较运算**、**取反运算**、**typeof**、**instanceof**。
- **never类型**：never类型不代表任何一种类型，可以抽象的理解为一个空集，同时never的类型的值可以赋给任何一个类型。

any类型和unknown类型都是顶层类型，而never类型是底层类型。

## Object类型

Object类型包含了所有对象、数组和函数。  
``const x :object = { foo : 123};``  
``const y :object = [1 , 2, 3];``  
``const z :object = (n :number) => n + 1;``  
Objects属于复合类型。**在使用new()命令时会生成包装对象**，只有Boolean、String、Number类型有对应的包装对象，即它们可以使用new命令的构造函数。构造函数生成的Object类型但是实质上还是对应类型的值。

## 字面量和包装对象

- **使用大写字母的为包装对象**：String
  - **Object**：ts中广义的对象，包含了一切能转换为值的类型，除了undefined和null类型，**通常使用{}**来表示Object
- **使用小写字母的为字面量**：string
  - **object**：ts中狭义的对象，表示**只能用字面量表示的对象**，只包含了对象、数组和函数。

大写类型包含了包装对象和字面量两种类型，但是小写字母只包含了字面量这一种类型，**通常在写代码时默认使用小写**，因为大写可能会导致一些出错情况。

## 值类型

TS中对于单个存在的值会定义为值类型，**在使用const命名变量的时候如果没有声明变量的类型的话，在进行类型推断时会将其推断为值类型**，但是如果声明的变量是对象的话，就算没有声明类型，在推断时会认为是对象类型而不是值类型。  
在值类型的表示中，**若`let x : 5`这句话表示x的类型为5**，实际上也是属于number型，但是属于number类型的一个子类，**在进行赋值时，父类的变量可以赋给子类，而子类的变量则不能赋给父类**,**如果想强行将子类赋值给父类的话需要使用as**，eg：`let x : 5 = (4+1) as 5`.

## 联合类型

指用多个类型连接起来表示一个新的类型，**类型中间\'|'**来进行连接。eg：

- ` let x : string|number； `这句话就表示x的类型可以是number型和string型。
- `let x : 'male' | 'female'`这句话就表示x的类型是string型，而且必须只能为‘male’或者‘female’，如果输入其他的的字符串则会报错。
